#include <iostream>
#include <bits/stdc++.h>

#include <cstring>
#include <cstdio>
using namespace std;

//归并排序版本
//右边的数字小于左边的数字
//那么左边的序列从当前位置到最后的所有数字一定都大于右边的这个数字
//逆序对就有 mid- p + 1 个

//记录交换次序

/**
背景
雷蒙德・巴比特（Raymond Babbitt）使他的兄弟查理（Charlie）发疯。最近，雷蒙德（Raymond）瞥了一眼，发现瞬间有246根牙签洒在地板上。他甚至可以数扑克牌。查理（Charlie）也很想能够做类似的事情。他想在类似的任务中击败他的兄弟。

问题
这就是查理的想法。想象一下，您得到了N个数字序列。目标是移动数字，以便最后对序列进行排序。唯一允许的操作是交换两个相邻的号码。让我们尝试一个例子：
开始于：2 8 0 3
交换（2 8）8 2 0 3
交换（2 0）8 0 2 3
交换（2 3）8 0 3 2
交换（8 0）0 8 3 2
交换（8 3）0 3 8 2
交换（8 2）0 3 2 8
交换（3 2）0 2 3 8
交换（3 8）0 2 8 3
交换（8 3）0 2 3 8

因此，序列（2 8 0 3）可以用九个相邻数字掉期进行排序。但是，甚至可以通过三个这样的交换对它进行排序：
开始于：2 8 0 3
交换（8 0）2 0 8 3
交换（2 0）0 2 8 3
交换（8 3）0 2 3 8

问题是：排序给定序列的相邻数字交换的最小数量是多少？由于查理没有雷蒙德的思维能力，他决定作弊。这是您发挥作用的地方。他要求您为他写一个回答问题的计算机程序。放心，他将为此付出非常高的奖金。
输入值
第一行包含方案的数量。
对于每种情况，您将获得一条包含以下内容的行：该行首先包含序列的长度N（1 <= N <= 1000），然后是序列的N个元素（每个元素是[-1000000，1000000]中的整数）。该行中的所有数字均由单个空格分隔。
输出量
使用包含“ Scenario #i：”的行开始每个方案的输出，其中i是从1开始的方案编号。然后打印一行，其中包含对给定的排序所必需的相邻数字互换的最小数量顺序。用空白行终止方案的输出。
样本输入
4
4 2 8 0 3
10 0 1 2 3 4 5 6 7 8 9
6 -42 23 6 28 -100 65537
5 0 0 0 0 0
样本输出
方案＃1：
3

方案＃2：
0

方案＃3：
5

方案＃4：
0
*/

int a[1005];
int cnt;
int help[1005];

///通过比较合并归并段
///合并的时候记录逆序对数
void Merge(int a[], int left, int mid, int right) {

    ///左区间的起点
    int i = left;

    ///右区间的起点
    int j = mid + 1;

    //临时数组下标
    int  index = 0;

    ///两个有且仅有一个越界
    ///段之间也可组成逆序对
    while(i <= mid && j <= right) {

        if(a[i] <= a[j]) {///左区间小于右区间
            help[index++] = a[i++];

        } else { ///左区间大于右区间

            //左边数值 > 右边数值
            //[3] 4 5       [1] 2 6
            help[index++] = a[j++];

            ///当前 i 所指数值 > j 所指数值
            ///i 及 i 以后的元素都大于 j 所指数值
            ///统计逆序对数（归并排序过程中合并的两个区间有序）
            cnt += mid - i + 1;
        }
    }

    //以下操作进执行其中一个
    while(i <= mid) { /// j 到头，组区间剩有数据
        help[index++] = a[i++];
    }

    while(j <= right) {/// i 到头
        help[index++] = a[j++];
    }

    index = 0;

    //赋值到待排序数组
    for(int k = left; k <= right; k++) {
        a[k] = help[index++];
    }
}

///归并排序
void MergeSort(int a[], int left, int right) {

    ///分解为一个元素(此时有序)
    if(left == right)
        return;

    /// 分解数组
    ///中间位置
    int mid = left + (right - left) / 2;

    ///划分左区间
    MergeSort(a, left, mid);

    ///划分右区间
    MergeSort(a, mid + 1, right);

    ///合并
    Merge(a, left, mid, right);
}
int main() {


    int N, i;

    //数据组数
    scanf("%d", &N);

    for(int k = 0; k < N; k++) {

        //数组长度
        int len;
        scanf("%d", &len);

        cnt = 0;

        //获取输入
        for(i = 0; i < len; i++) {
            scanf("%d", &a[i]);
        }

        MergeSort(a, 0, len - 1);

        printf("Scenario #%d:\n", k + 1);
        cout << cnt << endl << endl;

    }
    return 0;
}
