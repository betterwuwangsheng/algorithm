#include <bits/stdc++.h>

using namespace std;

/**
背景
雷蒙德・巴比特（Raymond Babbitt）使他的兄弟查理（Charlie）发疯。最近，雷蒙德（Raymond）瞥了一眼，发现瞬间有246根牙签洒在地板上。他甚至可以数扑克牌。查理（Charlie）也很想能够做类似的事情。他想在类似的任务中击败他的兄弟。

问题
这就是查理的想法。想象一下，您得到了N个数字序列。目标是移动数字，以便最后对序列进行排序。唯一允许的操作是交换两个相邻的号码。让我们尝试一个例子：
开始于：2 8 0 3
交换（2 8）8 2 0 3
交换（2 0）8 0 2 3
交换（2 3）8 0 3 2
交换（8 0）0 8 3 2
交换（8 3）0 3 8 2
交换（8 2）0 3 2 8
交换（3 2）0 2 3 8
交换（3 8）0 2 8 3
交换（8 3）0 2 3 8

因此，序列（2 8 0 3）可以用九个相邻数字掉期进行排序。但是，甚至可以通过三个这样的交换对它进行排序：
开始于：2 8 0 3
交换（8 0）2 0 8 3
交换（2 0）0 2 8 3
交换（8 3）0 2 3 8

问题是：排序给定序列的相邻数字交换的最小数量是多少？由于查理没有雷蒙德的思维能力，他决定作弊。这是您发挥作用的地方。他要求您为他写一个回答问题的计算机程序。放心，他将为此付出非常高的奖金。
输入值
第一行包含方案的数量。
对于每种情况，您将获得一条包含以下内容的行：该行首先包含序列的长度N（1 <= N <= 1000），然后是序列的N个元素（每个元素是[-1000000，1000000]中的整数）。该行中的所有数字均由单个空格分隔。
输出量
使用包含“ Scenario #i：”的行开始每个方案的输出，其中i是从1开始的方案编号。然后打印一行，其中包含对给定的排序所必需的相邻数字互换的最小数量顺序。用空白行终止方案的输出。
样本输入
4
4 2 8 0 3
10 0 1 2 3 4 5 6 7 8 9
6 -42 23 6 28 -100 65537
5 0 0 0 0 0
样本输出
方案＃1：
3

方案＃2：
0

方案＃3：
5

方案＃4：
0
*/

int a[1009];

int main() {
    int N, i, cnt, j;

    //数据组数
    scanf("%d", &N);

    for(int k = 0; k < N; k++) {

        //数组长度
        int len;
        scanf("%d", &len);

        //获取输入
        for(i = 0; i < len; i++) {
            scanf("%d", &a[i]);
        }

        cnt = 0;

        for(i = 0; i < len; i++) {
            for(j = 0; j < len - 1; j++ ) {
                if(a[j] > a[j + 1]) {//相邻元素比较，若逆序则交换（升序为左大于右，降序反之）
                    swap(a[j], a[j + 1]);
                    cnt++;
                }
            }
        }

//        if(k != N -1) {
        printf("Scenario #%d:\n", k + 1);
        cout << cnt<< endl << endl;

        // cout << endl;  输出空行
//        } else {
//            printf("Scenario #%d:\n", k + 1);
//            printf("%d", cnt);
//        }
    }
    return 0;
}
