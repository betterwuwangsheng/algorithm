#include <bits/stdc++.h>

using namespace std;

/**
题目描述
小K成功地破解了密文。但是乘车到X国的时候，发现钱包被偷了，于是无奈之下只好作快递员来攒足路费去Orz教主……

一个快递公司要将n个包裹分别送到n个地方，并分配给邮递员小K一个事先设定好的路线，小K需要开车按照路线给的地点顺序相继送达，且不能遗漏一个地点。小K得到每个地方可以签收的时间段，并且也知道路线中一个地方到下一个地方的距离。若到达某一个地方的时间早于可以签收的时间段，则必须在这个地方停留至可以签收，但不能晚于签收的时间段，可以认为签收的过程是瞬间完成的。

为了节省燃料，小K希望在全部送达的情况下，车的最大速度越小越好，就找到了你给他设计一种方案，并求出车的最大速度最小是多少。

输入格式
第1行为一个正整数n，表示需要运送包裹的地点数。

下面n行，第i+1行有3个正整数xi，yi，si，表示按路线顺序给出第i个地点签收包裹的时间段为[xi, yi]，即最早为距出发时刻xi，最晚为距出发时刻yi，从前一个地点到达第i个地点距离为si，且保证路线中xi递增。

可以认为s1为出发的地方到第1个地点的距离，且出发时刻为0。

输出格式
仅包括一个正数，为车的最大速度最小值，结果保留两位小数。

输入输出样例
输入 #1复制
3
1 2 2
6 6 2
7 8 4
输出 #1复制
2.00
说明/提示
对于20%的数据，n≤10；

对于30%的数据，xi，yi，si≤1000。

对于50%的数据，n≤1000；

对于100%的数据，n≤200000；xi≤yi≤10^8；si≤10^7。

时限1s

第一段用1的速度在时间2到达第1个地点，第二段用0.5的速度在时间6到达第2个地点，第三段用2的速度在时间8到达第3个地点。
*/
#define EPS 1e-6

typedef long double ld;

//求最大值最小值（最小值的最大值）使用二分答案解决
const int N = 2e5 + 10;

//左端点
int x[N];

//右端点
int y[N];

//距离
int s[N];

int n;
bool check(ld v) {

    //初始时刻
    ld t = 0;

    //对每一个地点检查可行性
    for(int i = 1; i <= n; i++) {

        //到达第一个地点的时间 t + s[i] / v
        //提前到达
        //[x[i], y[i]]
        if((t + s[i] / v) < x[i]) {

            //等待到 x[i]
            t = x[i];
        } else {

            //在 x[i] 之后到达
            t = t + s[i] / v;

            //检验是否在右端点之前到达(速度慢了)
            if(t > y[i]) {
                //超时到达 -> 速度不可行
                return false;
            }
        }
    }
    return true;
}

int main() {

    //地点数
    scanf("%d", &n);

    //正整数xi，yi，si，表示按路线顺序给出第i个地点签收包裹的时间段为[xi, yi
    //即最早为距出发时刻xi，最晚为距出发时刻yi，
    //从前一个地点到达第i个地点距离为si，且保证路线中xi递增。
    for(int i = 1; i <= n; i++) {
        scanf("%d %d %d", &x[i], &y[i], &s[i]);
    }

    //浮点数二分
    ld l = 0, r = 1e8;
    ld ans = 0;

    //由于(保留两位小数)是浮点数 ->  (a - b) > EPS
    //EPS = 1e-8
    //浮点二分
    while((r - l) >= 1e-8) {
        ld mid = l + (r - l) / 2;

        //检验 mid 是否是可行的最大速度
        if(check(mid)) {

            //可行的最大速度
            ans = mid;

            //查找最大速度的最小值
            r = mid;  //[左端点,mid]可能还有更小的值

        } else {

            //不可行
            l = mid;//[mid,右端点]可能还有更大的值
        }
    }
    //printf("%.2lf\n", ans);
    cout << fixed << setprecision(2) << ans << endl;
    system("pause");
    return 0;
}
