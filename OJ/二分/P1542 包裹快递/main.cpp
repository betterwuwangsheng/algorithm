#include <bits/stdc++.h>

using namespace std;

/**
题目描述
小K成功地破解了密文。但是乘车到X国的时候，发现钱包被偷了，于是无奈之下只好作快递员来攒足路费去Orz教主……

一个快递公司要将n个包裹分别送到n个地方，并分配给邮递员小K一个事先设定好的路线，小K需要开车按照路线给的地点顺序相继送达，且不能遗漏一个地点。小K得到每个地方可以签收的时间段，并且也知道路线中一个地方到下一个地方的距离。若到达某一个地方的时间早于可以签收的时间段，则必须在这个地方停留至可以签收，但不能晚于签收的时间段，可以认为签收的过程是瞬间完成的。

为了节省燃料，小K希望在全部送达的情况下，车的最大速度越小越好，就找到了你给他设计一种方案，并求出车的最大速度最小是多少。

输入格式
第1行为一个正整数n，表示需要运送包裹的地点数。

下面n行，第i+1行有3个正整数xi，yi，si，表示按路线顺序给出第i个地点签收包裹的时间段为[xi, yi]，即最早为距出发时刻xi，最晚为距出发时刻yi，从前一个地点到达第i个地点距离为si，且保证路线中xi递增。

可以认为s1为出发的地方到第1个地点的距离，且出发时刻为0。

输出格式
仅包括一个正数，为车的最大速度最小值，结果保留两位小数。

输入输出样例
输入 #1复制
3
1 2 2
6 6 2
7 8 4
输出 #1复制
2.00
说明/提示
对于20%的数据，n≤10；

对于30%的数据，xi，yi，si≤1000。

对于50%的数据，n≤1000；

对于100%的数据，n≤200000；xi≤yi≤10^8；si≤10^7。

时限1s

第一段用1的速度在时间2到达第1个地点，第二段用0.5的速度在时间6到达第2个地点，第三段用2的速度在时间8到达第3个地点。


Solution
做二分题目时，我们要弄清楚这样几点：
    二分什么
    如何判断是否可行 ( 即check函数的内容 )
    当二分到一个满足条件的解时，L , R 该如何移动
    针对以上三个问题，我们来一步一步解决。
        S1. 题目求速度，所以我们可以直接二分最大速度的值
        S2. 在check函数中可以直接进行模拟送包裹，在模拟过程当中进行
        判断（具体见代码）
        S3. 可能我们做二分题目会形成了思维定式，例如求最 大/小 值解的时
        候，若 mid 满足题意，则就将 L = mid + 1 或将 R = mid − 1
        然而，由于此题考虑到精度问题，如果按照上述操作，那么我们就会
        错过 1 / 0.01 = 100（及以上）个可能满足条件的解 （保留两位小数）。
        所以正确的格式应是：
            mid = (l + r) / 2;
            if (check(mid))
                Res = mid, r = mid;
            else
                l = mid;
        另外，由于本题数据原因对精度要求较高，所以在定义实数类型时要
        用 long double ，相与之搭配的输出应是 printf("%Lf") .
        到此为止，问题都已经解决。
*/
const int MX = 2e5 + 10;

//左端点时间
int x[MX];

//右端点时间
int y[MX];

//距离
int s[MX];
int N;
long double res;

bool check(long double v) {

    // sum 记录进行时间
    long double t = 0;
    for (int i = 1 ; i <= N ; i++) {

        //加上到达下个地点的时间
        t = t + s[i] / v;

        // 若超出签收时间右端点（即来晚了），说明以此速度不可行，直接返回false
        if (t > y[i])
            return false;

        // 如果小于签收时间左端点（即来早了），则等待至签收时间
        if (t < x[i])
            t = x[i];
    }

    //若至始至终没有迟到，则说明以此速度的方案可行
    return true;
}
int main() {
    scanf("%d", &N);

    //从 1 开始读入数组数据更方便
    for(int i = 1; i <= N; i++) {
        scanf("%d%d%d", &x[i], &y[i], &s[i]);
    }

    long double l, r, mid;
    l = 0, r = 1e9;

    //二分控制精度
    while((r - l) >= 1e-6) {
        mid = l + (r - l) / 2;
        if(check(mid)) {
            res = mid;
            r = mid;
        } else
            l = mid;
    }
    printf("%0.2lf\n", (double)res); //保留两位小数
    return 0;
}
